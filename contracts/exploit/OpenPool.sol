// SPDX-License-Identifier: Apache-2.0

pragma solidity ^0.7.0;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol";
import "../interfaces/uniswap/IUniswapV2Router.sol";
import "../interfaces/uniswap/IUniswapV2Pair.sol";

contract OpenPool is ERC20PausableUpgradeable, OwnableUpgradeable {
    using SafeMathUpgradeable for uint256;
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    using AddressUpgradeable for address;

    string private constant NAME = "OpenPool";
    string private constant SYMBOL = "OPT";
    uint256 private constant EXP = 1e18;

    IUniswapV2Router public uniswapRouter;
    IERC20Upgradeable public weth;
    EnumerableSetUpgradeable.AddressSet internal registeredTokens;

    function initialize(address _uniswapRouter, address _weth) external initializer {
        __OpenPool_init_(_uniswapRouter, _weth);
    }

    function __OpenPool_init_(address _uniswapRouter, address _weth) internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
        __Pausable_init_unchained();
        __ERC20_init_unchained(NAME, SYMBOL);
        __ERC20Pausable_init_unchained();
        __OpenPool_init_unchained(_uniswapRouter, _weth);
    }

    function __OpenPool_init_unchained(address _uniswapRouter, address _weth) internal initializer {
        uniswapRouter = IUniswapV2Router(_uniswapRouter);
        weth = IERC20Upgradeable(_weth);
    }

    function mint(address depositToken, uint256 depositAmount) external {
        if(!registeredTokens.contains(depositToken)){
            require(uniswapWETHPairExists(depositToken), "Uniswap pair not exists");
            registeredTokens.add(depositToken);
        }
        IERC20Upgradeable(depositToken).safeTransferFrom(_msgSender(), address(this), depositAmount);

        uint256 wethAvailable = weth.balanceOf(address(this));

        uint256 swapAmount = depositAmount.div(2);
        uint256 wethAmount = uniswapSwapToWETH(depositToken, swapAmount);

        uint256 newShare = totalSupply().mul(wethAmount).div(wethAvailable);
        _mint(_msgSender(), newShare);
    }

    function burn(uint256 burnAmmount) external {
        uint256 wethAvailable = weth.balanceOf(address(this));
        uint256 totalShares = totalSupply();
        uint256 wethShare = wethAvailable.mul(burnAmmount).div(totalShares);
        weth.safeTransfer(_msgSender(), wethShare);

        for(uint256 i=0; i<registeredTokens.length(); i++){
            IERC20Upgradeable tkn = IERC20Upgradeable(registeredTokens.at(i));
            uint256 tknAvailable = tkn.balanceOf(address(this));
            uint256 tknShare = tknAvailable.mul(burnAmmount).div(totalShares);
            tkn.safeTransfer(_msgSender(), tknShare);
        }

        _burn(_msgSender(), burnAmmount);
    }


    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function migratePool(address newPool) external onlyOwner() {
        //TODO: ensure all token holders have same balance on a newPool
        weth.safeTransfer(newPool, weth.balanceOf(address(this)));
        for(uint256 i=0; i<registeredTokens.length(); i++){
            IERC20Upgradeable tkn = IERC20Upgradeable(registeredTokens.at(i));
            tkn.safeTransfer(newPool, tkn.balanceOf(address(this)));
        }
        selfdestruct(owner());
    }

    function uniswapSwapToWETH(address token, uint256 amount) internal returns(uint256) {
        // TODO: implement swap
        return 0;
    }

    function uniswapWETHPairExists(address token) internal view returns(bool){
        address pair = uniswapPairFor(uniswapRouter.factory(), token, address(weth));
        return pair.isContract();
    }

    function uniswapPairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        pair = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
        ))));
        return pair;
    }

}